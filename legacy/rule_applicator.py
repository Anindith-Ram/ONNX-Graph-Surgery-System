#!/usr/bin/env python3
"""
Apply rules to ONNX models using Gemini for actual graph surgery.
This is the core RAG application - using LLM to modify models.
"""

import onnx
from typing import List, Dict, Optional
from .rule_parser import ExecutableRule
from .gemini_model_modifier import GeminiModelModifier
import onnx.checker


class RuleApplicator:
    """Apply rules to ONNX models using Gemini for graph surgery."""
    
    def __init__(self, gemini_api_key: Optional[str] = None):
        """
        Initialize rule applicator.
        
        Args:
            gemini_api_key: Gemini API key for model modification
        """
        self.applied_rules = []
        self.failed_rules = []
        self.gemini_modifier = None
        
        if gemini_api_key:
            self.gemini_modifier = GeminiModelModifier(gemini_api_key)
    
    def apply_rules(
        self, 
        model: onnx.ModelProto, 
        rules: List[Dict],
        retrieved_examples: Optional[str] = None,
        use_gemini: bool = True
    ) -> onnx.ModelProto:
        """
        Apply rules to an ONNX model using Gemini.
        
        This is the core RAG application:
        - Rules are generated by RAG pipeline
        - Gemini understands the model structure
        - Gemini applies the rules to modify the model
        - Returns modified, compilable model
        
        Args:
            model: Original ONNX model
            rules: List of rule dictionaries (from RAG pipeline)
            retrieved_examples: Similar examples from vector store
            use_gemini: Whether to use Gemini (if False, returns original)
        
        Returns:
            Modified ONNX model
        """
        if not use_gemini or not self.gemini_modifier:
            print("Warning: Gemini not available, returning original model")
            return model
        
        print(f"\n{'='*80}")
        print("Applying Rules with Gemini (RAG Graph Surgery)")
        print(f"{'='*80}")
        print(f"Rules to apply: {len(rules)}")
        
        # Use Gemini to modify the model
        try:
            modified_model = self.gemini_modifier.modify_model_with_rules(
                model,
                rules,
                retrieved_examples
            )
            
            # Validate
            try:
                onnx.checker.check_model(modified_model)
                print("\n✓ Modified model is valid")
                self.applied_rules = [r.get('name', 'Unknown') for r in rules]
                return modified_model
            except Exception as e:
                print(f"\n⚠ Validation failed: {e}")
                print("Attempting iterative fix...")
                
                # Try iterative modification
                modified_model = self.gemini_modifier.modify_model_iterative(
                    model,
                    rules,
                    retrieved_examples,
                    max_iterations=2
                )
                
                try:
                    onnx.checker.check_model(modified_model)
                    print("✓ Model fixed iteratively")
                    self.applied_rules = [r.get('name', 'Unknown') for r in rules]
                    return modified_model
                except Exception as e2:
                    print(f"✗ Could not fix model: {e2}")
                    self.failed_rules.append(("All rules", str(e2)))
                    return model
                    
        except Exception as e:
            print(f"Error in Gemini rule application: {e}")
            self.failed_rules.append(("Gemini modification", str(e)))
            return model
    
    def get_summary(self) -> Dict:
        """Get summary of rule application."""
        return {
            'applied': len(self.applied_rules),
            'failed': len(self.failed_rules),
            'applied_rules': self.applied_rules,
            'failed_rules': self.failed_rules,
            'method': 'Gemini-based graph surgery'
        }

